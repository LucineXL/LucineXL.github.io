
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lucine-XL</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="LucineXL,"> 
    <meta name="description" content="我是一个小码农~,"> 
    <meta name="author" content="Lucine"> 
    <link rel="alternative" href="atom.xml" title="Lucine-XL" type="application/atom+xml"> 
    <link rel="icon" href="/img/li.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <!-- <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> -->
    <script>
    //   (adsbygoogle = window.adsbygoogle || []).push({
    //     google_ad_client: "ca-pub-8691406134231910",
    //     enable_page_level_ads: true
    //   });
    </script>

</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">初始docker</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">初始docker</h1>
        <div class="stuff">
            <span>十月 19, 2020</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/docker/">docker</a></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="docker-简介"><a href="#docker-简介" class="headerlink" title="docker 简介"></a>docker 简介</h3><h4 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h4><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器</p>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/3/17277fe9f810f632?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/3/17277fece35ee96e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<h4 id="为什么要使用docker"><a href="#为什么要使用docker" class="headerlink" title="为什么要使用docker"></a>为什么要使用docker</h4><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<ol>
<li>更高效的利用系统资源</li>
<li>更快速的启动时间</li>
<li>一致的运行环境</li>
<li>持续交付和部署</li>
<li>更轻松的迁移</li>
<li>更轻松的维护和扩展</li>
</ol>
<p>与传统的虚拟机比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">容器</th>
<th style="text-align:center">虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">启动</td>
<td style="text-align:center">秒级</td>
<td style="text-align:center">分钟级</td>
</tr>
<tr>
<td style="text-align:center">硬盘使用</td>
<td style="text-align:center">一般为MB</td>
<td style="text-align:center">一般为GB</td>
</tr>
<tr>
<td style="text-align:center">性能</td>
<td style="text-align:center">接近原生</td>
<td style="text-align:center">弱于</td>
</tr>
<tr>
<td style="text-align:center">系统支持量</td>
<td style="text-align:center">单机支持上千个容器</td>
<td style="text-align:center">一般几十个</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注： 此段内容参考自  <a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">Docker – 从入门到实践</a></p>
</blockquote>
<h3 id="docker-的一些基本概念"><a href="#docker-的一些基本概念" class="headerlink" title="docker 的一些基本概念"></a>docker 的一些基本概念</h3><p>Docker 包括三个基本的概念：</p>
<ul>
<li>镜像 （Image）</li>
<li>容器 （Container）</li>
<li>仓库 （Repository）</li>
</ul>
<p>可以用下面这张图简单认识三者之间的关系</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/7/16da661eef3572d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>镜像存放在镜像仓库中，Docker 官方也提供了镜像仓库 hub.docker.com/ ，我们可以从这里下载我们所需要的镜像，当然也可以将我们制作好的镜像存放到仓库中。当我们下载好镜像之后，我们可以通过 run 命令来创建对应的容器，一个镜像可以创建多个容器，每个容器，相互之间不会产生影响。</p>
<h4 id="Image-镜像"><a href="#Image-镜像" class="headerlink" title="Image 镜像"></a>Image 镜像</h4><p>docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>镜像采用了分层存储的方式。 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h4 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container 容器"></a>Container 容器</h4><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<h4 id="Repository-仓库"><a href="#Repository-仓库" class="headerlink" title="Repository 仓库"></a>Repository 仓库</h4><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p>
<p>一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>
<h3 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h3><p>可以使用<code>homebrew</code>进行安装<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>docker</span><br></pre></td></tr></table></figure></p>
<p>安装成功后， 可以使用 <code>docker --version</code> 检查安装后的版本</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjvnre6aenj30gk03umxd.jpg" alt></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><ol>
<li>搜索镜像, 以node 镜像为例</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjvnv1c8o8j31mq0kkte4.jpg" alt></p>
<p>上面字段分别为： 镜像名称， 描述， star数量，是否为官方镜像， 是否为自动生成</p>
<ol start="2">
<li>下载镜像</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">pull</span> 镜像名<span class="selector-attr">[:版本]</span></span><br></pre></td></tr></table></figure>
<p>不输入版本号时 默认为 latest</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjvnydmm4pj30wo0e8tb0.jpg" alt></p>
<ol start="3">
<li>查看本地镜像</li>
</ol>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">image</span> <span class="keyword">ls</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjvnyq9snzj31hg05m3zp.jpg" alt></p>
<ol start="4">
<li>删除镜像</li>
</ol>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image rm 镜像名/镜像<span class="built_in">id</span></span><br><span class="line">docker rmi 镜像名/镜像<span class="built_in">id</span></span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjvnzmvrbcj30ze0cctbv.jpg" alt></p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><ol>
<li>创建容器</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> [选项] 镜像</span></span><br></pre></td></tr></table></figure>
<p>如果本地不存在该镜像时， 会先到镜像仓库下载该镜像</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjvontx2v9j31py0ms7af.jpg" alt></p>
<p>上面的例子中， 本地没有nginx镜像， 先拉取nginx镜像，  -p 参数将容器中的 80 端口映射到宿主机中的 8080 端口</p>
<p>此时访问本地的 <code>http://localhost:8080/</code>, 即可看见nginx欢迎页</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjvop5ahe9j30zu0g2aby.jpg" alt></p>
<ol start="2">
<li>查看运行中的容器</li>
</ol>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker <span class="keyword">container</span> <span class="keyword">ls</span></span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjvoqh7g5yj31n802ut98.jpg" alt></p>
<p>图中显示的即为我们刚刚启动的nginx容器</p>
<p>我们使用ctrl + c 关闭容器后， 再次查询运行中的容器</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjvorv9absj31fm01qwen.jpg" alt></p>
<p>此时并没有正在运行中的容器</p>
<p>加上 -a 参数后 可以查看处于停止状态的容器</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjvoss43yvj31qq0423zm.jpg" alt></p>
<ol start="3">
<li>停止容器</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="keyword">stop</span> 容器<span class="keyword">id</span>/容器名</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>启动容器</li>
</ol>
<p>容器停止后，可以重新启动，不需要重新创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="keyword">start</span> 容器<span class="keyword">id</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>删除容器</li>
</ol>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">container</span> rm 容器id <span class="comment">// 删除一个容器</span></span><br><span class="line">docker <span class="keyword">container</span> rm id1 id2 <span class="comment">// 使用空格隔开，可删除多个容器</span></span><br><span class="line">docker <span class="keyword">container</span> prune  <span class="comment">// 删除所有处于停止状态的容器</span></span><br></pre></td></tr></table></figure>
<h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>docker 的 仓库包括 共有仓库 和 私有仓库，  共有仓库可以通过  <code>docker hub</code> 访问</p>
<p><br><br><br><br>参考文献：</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">Docker – 从入门到实践</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                    
                        <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci='875d3015f05abfc0a79b'
        data-cs='3192ac1526e44e82c6ff33702190a4123689a827'
        data-r='LucineXL.github.io'
        data-o='LucineXL'
        data-a='LucineXL'
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>


<!-- 
 -->
</html>